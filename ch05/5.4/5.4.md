# Exercises for Section 5.4

### 5.4.1

We mentioned in Section 5.4.2 that it is possible to deduce what grammar symbol an LR state in the parse stack represents. How do we deduce this information?

#### Solution

See Algorithm 4.44.

### 5.4.2

Rewrite the following SDT:

    A -> A {a} B | A B {b} | 0
    B -> B {c} A | B A {d} | 1
    
so that the underlying grammar is not left-recursive.

### 5.4.3 !

The following SDT computes the value of a string composed of 0s and 1s. It interprets the input symbol string as a positive binary number.

    B -> B_1 0 {B.val = 2 * B_1.val}
       | B_1 1 {B.val = 2 * B_1.val + 1}
       | 1 {B.val = 1}
       
Rewrite this SDT so that the underlying grammar is no longer left-recursive, but can still compute the same B.val value for the entire input string.

#### Solution

Extract the left common factor:

    B -> B_1 digit {B.val = 2 * B_1.val + digit.val}
       | 1 {B.val = 1}
    digit -> 0 {digit.val = 0} 
           | 1 {digit.val = 1}

In a left-recursive production of the form `A = A a | b`, a is `digit {B.val = 2 * B_1.val + digit.val}`, and b is `1`.

After eliminating left recursion, we get:

    B -> 1 {A.i = 1} A
    A -> digit {A_1.i = 2 * A.i + digit.val} A_1 {A.val = A_1.val}
       | ε {A.val = A.i}
    digit -> 0 {digit.val = 0} 
           | 1 {digit.val = 1}

### 5.4.4 !

Write an L-attributed SDD similar to Example 5.19 for the following productions. Each production here represents a common C-like control flow structure. You may need to generate a three-address statement to jump to a certain label L, in which case you can generate the statement `goto L`.

1. S -> if ( C ) S_1 else S_2
2. S -> do S_1 while ( C )
3. S -> '{' L '}'; L -> L S | ε

Please note that any statement in the list may contain a jump instruction from its interior to the next statement, so simply generating code for each statement in sequence is not sufficient.

#### Solution

1. S -> if ( C ) S_1 else S_2

        L_1 = new()
        C.false = L_1  
        S_1.next = S.next
        S.code = C.code || S_1.code || label L_1 || S_2.code                              

2. S -> do S_1 while ( C )

       L_1 = new()
       C.true = L_1
       S.code = label L_1 || S_1.code || C.code
       

### 5.4.5

Following the method of Example 5.19, convert each of the SDDs obtained in Exercise 5.4.4 into an SDT.

#### Solution

1. S -> if ( C ) S_1 else S_2

        S -> if (     {new L_1; C.false = L_1}   
             C )      {S_1.next = S.next}
             S_1 else
             S_2      {S.code = C.code || S_1.code || label L_1 || S_2.code}

2. S -> do S_1 while ( C )

       S -> do           {new L_1} 
            S_1 while (  {C.true = L_1}
            C )          {S.code = label L_1 || S_1.code || C.code}

### 5.4.6

Modify the SDD in Figure 5.25 to include a synthesised attribute B.le, which is the length of a box. The length of the box obtained by juxtaposing two boxes is the sum of the lengths of these two boxes. Then add your new rules to the appropriate places in the SDT of Figure 5.26.

### 5.4.7

Modify the SDD in Figure 5.25 to include superscripts, represented by the operator `sup` between boxes. If box B_2 is a superscript of box B_1, then place the baseline of B_2 above the baseline of B_1, with the distance between the two baselines being 0.6 times the size of B_1. Add the new productions and rules to the SDT of Figure 5.26.

#### Solution for 5.4.6 and 5.4.7
 
    1) S -> B               B.ps = 10
                            B.wd = 
                            
    2) S -> B_1 B_2         B_1.ps = B.ps
                            B_2.ps = B.ps
                            B.wd = B_1.wd + B_2.wd
                            B.ht = max(B_1.ht, B_2.ht)
                            B.dp = max(B_1.dp, B_2.dp)
    
    3) B -> B_1 sub B_2     B_1.ps = B.ps
                            B_2.ps = 0.7 * B.ps
                            B.wd = B_1.wd + B_2.wd
                            B.ht = max(B_1.ht, B_2.ht - 0.25 * B.ps)
                            B.dp = max(B_1.dp, B_2.dp + 0.25 * B.ps)
    
    4) B -> B_1 sup B_2     B_1.ps = B.ps
                            B_2.ps = 0.6 * B.ps
                            B.wd = B_1.wd + B_2.wd
                            B.ht = max(B_1.ht, B_2.ht + 0.6 * B.ps)
                            B.dp = max(B_1.dp, B_2.dp - 0.6 * B.ps)    
   
    5) B -> ( B_1 )         B_1.ps = B.ps
                            B.wd = B_1.wd
                            B.ht = B_1.ht
                            B.dp = B_1.dp
    
    6) B -> text            B.wd = getWd(B.ps, text.lexval)
                            B.ht = getHt(B.ps, text.lexval)
                            B.dp = getDp(B.ps, text.lexval)