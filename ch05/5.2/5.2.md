# Exercises for Section 5.2

### 5.2.1

What are all the topological sorts of the dependency graph in Figure 5-7?

#### Solution

    [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
    [ 1, 2, 3, 5, 4, 6, 7, 8, 9 ],
    [ 1, 2, 4, 3, 5, 6, 7, 8, 9 ],
    [ 1, 3, 2, 4, 5, 6, 7, 8, 9 ],
    [ 1, 3, 2, 5, 4, 6, 7, 8, 9 ],
    [ 1, 3, 5, 2, 4, 6, 7, 8, 9 ],
    [ 2, 1, 3, 4, 5, 6, 7, 8, 9 ],
    [ 2, 1, 3, 5, 4, 6, 7, 8, 9 ],
    [ 2, 1, 4, 3, 5, 6, 7, 8, 9 ],
    [ 2, 4, 1, 3, 5, 6, 7, 8, 9 ]

See the algorithm in [5.2.1.js](5.2.1.js)

### 5.2.2

For the SDD in Figure 5-8, provide the corresponding annotated parse trees for the following expressions:

1. int a, b , c
2. float w, x, y, z

#### Solution

1. int a, b, c
    
    ![5 2 2-1](https://f.cloud.github.com/assets/340282/890975/faf883c0-fa43-11e2-8d6c-eec2e33f771e.gif)


### 5.2.3

Suppose we have a production A -> BCD. The four non-terminals A, B, C, and D each have two attributes: a synthesised attribute s and an inherited attribute i. For each of the following sets of rules, indicate (1) whether these rules satisfy the requirements for an S-attributed definition, (2) whether these rules satisfy the requirements for an L-attributed definition, and (3) whether there exists an evaluation procedure consistent with these rules.

1. A.s = B.i + C.s
2. A.s = B.i + C.s , D.i = A.i + B.s
3. A.s = B.s + D.s
4. ! A.s = D.i , B.i = A.s + C.s , C.i = B.s , D.i = B.i + C.i

#### Solution

1. No, ?
2. No, Yes
3. Yes, Yes
4. No, No


### 5.2.4 !

This grammar generates binary numbers containing a "decimal point":

    S -> L.L|L
    L -> LB|B
    B -> 0|1

Design an L-attributed SDD to compute S.val, which is the decimal value of the input string. For example, the string 101.101 should be translated to the decimal number 5.625.

#### Solution

<table>
    <thead>
        <tr>
            <th></th>
            <th>Production</th>
            <th>Semantic Rule</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1)</td>
            <td>S -> L_1.L_2</td>
            <td>
                L_1.isLeft = true<br/>
                L_2.isLeft = false<br/>
                S.val = L_1.val + L_2.val
            </td>
        </tr>
        <tr>
            <td>2)</td>
            <td>S -> L</td>
            <td>
                L.isLeft = true<br/>
                S.val = L.val
            </td>
        </tr>
        <tr>
            <td>3)</td>
            <td>L -> L_1B</td>
            <td>
                L_1.isLeft = L.isLeft<br/>
                L.len = L_1.len + 1<br/> 
                L.val = L.isLeft ? L_1.val * 2 + B.val : L_1.val + B.val * 2^(-L.len)
            </td>
        </tr>
        <tr>
            <td>4)</td>
            <td>L -> B</td>
            <td>
                L.len = 1<br/>
                L.val = L.isLeft ? B.val : B.val/2
            </td>
        </tr>  
        <tr>
            <td>5)</td>
            <td>B -> 0</td>
            <td>B.val = 0</td>
        </tr>
        <tr>
            <td>6)</td>
            <td>B -> 1</td>
            <td>B.val = 1</td>
        </tr>
    </tbody>
</table>

Where:

- isLeft is an inherited attribute, indicating whether the node is to the left of the decimal point.
- len is a synthesised attribute, indicating the length of the binary string contained in the node.
- val is a synthesised attribute.

### 5.2.5 !!

Design an S-attributed SDD for the grammar and translation described in Exercise 5.2.4.

#### Solution

<table>
    <thead>
        <tr>
            <th></th>
            <th>Production</th>
            <th>Semantic Rule</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1)</td>
            <td>S -> L_1.L_2</td>
            <td>
                S.val = L_1.val + L_2.val/L_2.f
            </td>
        </tr>
        <tr>
            <td>2)</td>
            <td>S -> L</td>
            <td>
                S.val = L.val
            </td>
        </tr>
        <tr>
            <td>3)</td>
            <td>L -> L_1B</td>
            <td>
                L.val = L_1.val*2 + B.val</br>
                L.f = L_1.f * 2
            </td>
        </tr>
        <tr>
            <td>4)</td>
            <td>L -> B</td>
            <td>
                L.val = B.val</br>
                L.f = 2
            </td>
        </tr>
        <tr>
            <td>5)</td>
            <td>B -> 0</td>
            <td>B.val = 0</td>
        </tr>
        <tr>
            <td>6)</td>
            <td>B -> 1</td>
            <td>B.val = 1</td>
        </tr>
    </tbody>
</table>        

### 5.2.6 !!

Implement Algorithm 3.23 using an L-attributed SDD on a top-down parsable grammar. This algorithm converts a regular expression into an NFA. Assume there is a lexical token `char` that represents any character, and `char.lexval` is the character it represents. You can assume that there is a function `new()` that returns a new state, which is a state that has not been previously returned by this function. Use any convenient representation to describe the translation of this NFA.