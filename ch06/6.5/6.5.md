# Exercises for Section 6.5

### 6.5.1

Assume that the function `widen` in Figure 6-26 can handle all types in the hierarchy of Figure 6-25a, translate the following expressions. Assume c and d are character types, s and t are short integers, i and j are integers, and x is a floating-point type.

1. x = s + c
2. i = s + c
3. x = (s + c) * (t + d)

#### Solution

1. x = s + c
 
        t1 = (int) s
        t2 = (int) c
        t3 = t1 + t2
        x = (float) t3
            
2. i = s + c

        t1 = (int) s
        t2 = (int) c
        i = t1 + t2
        
3. x = (s + c) * (t + d)

        t1 = (int) s
        t2 = (int) c
        t3 = t1 + t2
        t4 = (int) t
        t5 = (int) d
        t6 = t4 + t5
        t7 = t3 + t6
        x = (float) t7


### 6.5.2

As in Ada, we assume that each expression must have a unique type, but we can only derive a set of possible types from a subexpression itself. That is, applying function E1 to parameter E2 (grammar production is E -> E1(E2)) has the following rule:

    E.type = {t | for some s in E2.type, s -> t is in E1.type}
    
Describe an SDD that can determine the unique type of each subexpression. It first uses the attribute `type` to synthesise a set of possible types in a bottom-up manner. After determining the unique type of the entire expression, it determines the value of the attribute `unique` in a top-down manner, where this attribute represents the type of each subexpression.