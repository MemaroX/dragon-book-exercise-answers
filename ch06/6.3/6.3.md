# Exercises for Section 6.3

### 6.3.1

Determine the type and relative address of each identifier in the following sequence of declarations.

    float x;
    record {float x; float y;} p;
    record {int tag; float x; float y;} q;
    
#### Solution

SDT
   
    S ->                  {top = new Evn(); offset = 0;}
         D 
    D -> T id;            {top.put(id.lexeme, T.type, offset);
                           offset += T.width}
         D1
    D -> Îµ
    T -> int              {T.type = integer; T.width = 4;}
    T -> float            {T.type = float; T.width = 8;}
    T -> record '{'
                          {Evn.push(top), top = new Evn();
                           Stack.push(offset), offset = 0;}
         D '}'            {T.type = record(top); T.width = offset;
                           top = Evn.top(); offset = Stack.pop();}
    
Identifier types and relative addresses:

    line id      type        offset   Evn
    
      1) x       float       0        1
    
      2) x       float       0        2
      2) y       float       8        2
      2) p       record()    8        1
    
      3) tag     int         0        3
      3) x       float       4        3
      3) y       float       12       3
      3) q       record()    24       1     

### 6.3.2 !

Extend the handling of field names in Figure 6-18 to classes and single-inheritance hierarchies.

1. Provide an implementation of the class `Evn`. This implementation should support symbol table chaining, so that a subclass can redefine a field name, and can also directly reference a field name in a superclass.
2. Provide a translation scheme that can allocate contiguous data areas for fields in a class, including inherited fields. Inherited fields must maintain the relative addresses they obtained when storage was allocated for the superclass.