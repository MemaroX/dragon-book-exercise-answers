# Exercises for Section 6.6

### 6.6.1

Add rules to the syntax-directed definition in Figure 6-36 to handle the following control flow constructs:

1. A repeat statement: `repeat S while B`
2. ! A for loop statement: `for (S1; B; S2) S3`

#### Solution

    Production                  Syntax Rule
    
    S -> repeat S1 while B      S1.next = newlabel()
                                B.true = newlabel()
                                B.false = S.next
                                S.code = label(B.true) || S1.code
                                    || label(S1.next) || B.code
                                    
    S -> for (S1; B; S2) S3     S1.next = newlabel()
                                B.true = newlabel()
                                B.false = S.next
                                S2.next = S1.next
                                S3.next = newlabel()
                                S.code = S1.code
                                    || label(S1.next) || B.code
                                    || label(B.true) || S3.code
                                    || label(S3.next) || S2.code
                                    || gen('goto', S1.next)

### 6.6.2

Modern computers attempt to execute multiple instructions at the same time, including various branch instructions. Therefore, when a computer speculatively pre-executes a branch, but the actual control flow enters another branch, the cost is very high. Thus, we hope to reduce the number of branches as much as possible. Note that in the implementation of the while loop statement in Figure 6-35c, each iteration has two branches: one from condition B into the loop body, and the other branch jumps back to the code for B. Based on the consideration of minimizing branches, we usually prefer to implement `while(B) S` as `if(B) {repeat S until !(B)}`. Give the code layout for this translation method, and modify the rule for the while loop statement in Figure 6-36.

#### Solution

    Production               Syntax Rule
    
    S -> if(B) {             B.true = newlabel()    
            repeat S1        B.false = S.next            
            until !(B)       S1.next = newlabel()
         }                   S.code = B.code
                                 || label(B.true) || S1.code
                                 || label(S1.next) || B.code

### 6.6.3!

Assume that an XOR operation exists in C. Write the code generation rules for this operator in the style of Figure 6-37.

#### Solution

`B1 ^ B2` is equivalent to `!B1 && B2 || B1 && !B2` (operator precedence: `!` > `&&` > `||`)

    Production      Syntax Rule
    
    B -> B1 ^ B2    B1.true = newlabel()
                    B1.false = newlabel()
                    
                    B2.true = B.true
                    B2.false = B1.true
                    
                    b3 = newboolean()
                    b3.code = B1.code
                    b3.true = newlabel()
                    b3.false = B.false
                    
                    b4 = newboolean()
                    b4.code = B2.code
                    b4.true = B.false
                    b4.false = B.true
                    
                    S.code = B1.code
                        || label(B1.false) || B2.code
                        || label(B1.true) || b3.code
                        || label(b3.true) || b4.code
                        
### 6.6.4

Using the translation scheme introduced in Section 6.6.5 to avoid goto statements, translate the following expressions:

1. if (a==b && c==d || e==f) x == 1
2. if (a==b || c==d || e==f) x == 1
3. if (a==b || c==d && e==f) x == 1
    
#### Solution

1. if (a==b && c==d || e==f) x == 1

            ifFalse a==b goto L3 
            if c==d goto L2
        L3: ifFalse e==f goto L1
        L2: x == 1
        L1:

2. if (a==b || c==d || e==f) x == 1

            if a==b goto L2
            if c==d goto L2
            ifFalse e==f goto L1
        L2: x==1
        L1:

3. if (a==b || c==d && e==f) x == 1

            if a==b goto L2
            ifFalse c==d goto L1
            ifFalse e==f goto L1
        L2: x==1
        L1:
        
### 6.6.5

Based on the syntax-directed definitions given in Figures 6-36 and 6-37, provide a translation scheme.

### 6.6.6

Using rules similar to those in Figures 6-39 and 6-40, modify the semantic rules in Figures 6-36 and 6-37 to allow control flow to pass through.

#### Solution

Only supplementing the parts not answered in the book:

    Production              Syntax Rule
                        
    S -> if(B) S1 else S2   B.true = fall
                            B.false = newlabel()
                            S1.next = S.next
                            S2.next = S.next
                            S.code = B.code 
                                || S1.code
                                || gen('goto' S1.next)
                                || label(B.false) || S2.code
                                
    S -> while(B) S1        begin = newlabel()
                            B.true = fall
                            B.false = S.next
                            S1.next = begin
                            S.code = label(begin) || B.code
                                || S1.code
                                || gen('goto' begin)
                                
    S -> S1 S2              S1.next = fall
                            S2.next = S.next
                            S.code = S1.code || S2.code
                            
    B -> B1 && B2           B1.true = fall
                            B1.false = if B.false == fall
                                       then newlabel()
                                       else B.false
                            B2.true = B.true
                            B2.false = B.false
                            B.code = if B.false == fall
                                     then B1.code || B2.code || label(B1.false)
                                     else B1.code || B2.code

### 6.6.7!

The semantic rules in Exercise 6.6.6 generate some unnecessary labels. Modify the rules for statements in Figure 6-36 to create only necessary labels. You can use the special symbol `deferred` to represent a label that has not yet been created. Your semantic rules must be able to generate code similar to Example 6.21.

### 6.6.8!!

Section 6.6.5 discusses how to use pass-through code to minimise the number of jump instructions in the generated intermediate code. However, it does not fully consider replacing a condition with its complement, for example, replacing `if a < b goto L1; goto L2` with `ifFalse a >= b goto L2; goto L1`. Provide a syntax-directed definition that can utilise this replacement method when needed.