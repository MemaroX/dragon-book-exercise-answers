# Exercises for Section 6.4

### 6.4.1

Add rules corresponding to the following productions to the translation scheme in Figure 6-19:

1. E -> E1 * E2
2. E -> +E1

#### Solution

    Production           Semantic Rule

    E -> E1 * E2    { E.addr = new Temp();
                      E.code = E1.code || E2.code ||
                               gen(E.addr '=' E1.addr '*' E2.addr); }
                             
       | +E1        { E.addr = E1.addr;
                      E.code = E1.code; }

### 6.4.2

Repeat Exercise 6.4.1 using the incremental translation scheme of Figure 6-20.
 
#### Solution

    Production           Semantic Rule

    E -> E1 * E2    { E.addr =  new Temp();
                      gen(E.addr '=' E1.addr '*' E2.addr); }
                             
       | +E1        { E.addr = E1.addr; }

### 6.4.3

Use the translation scheme of Figure 6-22 to translate the following assignment statements:

1. x = a[i] + b[j]
2. x = a[i][j] + b[i][j]
3. ! x = a[b[i][j]][c[k]]

#### Solution

1. x = a[i] + b[j]

    Parse tree:

    ![6 4 3-1](https://f.cloud.github.com/assets/340282/1085302/1cba4a7e-15ca-11e3-842b-29a5d658b808.gif)

    Three-address code:
    
        t_1 = i * awidth
        t_2 = a[t_1]
        t_3 = j * bwidth
        t_4 = b[t_3]
        t_5 = t_2 + t_4
        x = t_5

2. x = a[i][j] + b[i][j]

    Parse tree:
    
    ![6 4 3-2](https://f.cloud.github.com/assets/340282/1087467/fb6b0634-1618-11e3-9ccc-2044c8c62c8b.gif)

    Three-address code:
    
        t_1 = i * ai_width
        t_2 = j * aj_width
        t_3 = t_1 + t_2
        t_4 = a[t_3]
        t_5 = i * bi_width
        t_6 = j * bj_width
        t_7 = t_5 + t_6
        t_8 = b[t_7]
        t_9 = t_4 + t_8
        x = t_9

3. ! x = a[b[i][j]][c[k]]

### 6.4.4 !

Modify the translation scheme of Figure 6-22 to suit Fortran-style data references, that is, an n-dimensional array reference is `id[E1, E2, ..., En]`.

#### Solution

Only the L production needs to be modified (as in Figure 6-22, elimination of left recursion is not considered):

    L -> id[A]  { L.addr = A.addr; 
                  global.array = top.get(id.lexeme); }
                  
    A -> E      { A.array = global.array;
                  A.type = A.array.type.elem;
                  A.addr = new Temp();
                  gen(A.addr '=' E.addr '*' A.type.width); }
                  
    A -> A1,E   { A.array = A1.array;
                  A.type = A1.type.elem;
                  t = new Temp();
                  A.addr = new Temp();
                  gen(t '=' E.addr '*' A.type.length);
                  gen(A.addr '=' A1.addr '+' t); }

#### Note

Let `a` represent an i*j array, with a single element width of `w`.

    a.type = array(i, array(j, w))
    a.type.length = i
    a.type.elem = array(j, w)


### 6.4.5

Generalise formula 6.7 to multi-dimensional data, and indicate which values can be stored in the symbol table and used to calculate the offset. Consider the following cases:

1. A two-dimensional array A, stored in row-major order. The subscript of the first dimension ranges from l_1 to h_1, and the subscript of the second dimension ranges from l_2 to h_2. The width of a single array element is w.
2. The other conditions are the same as in 1, but column-major order is used.
3. ! A k-dimensional array A, stored in row-major order, with an element width of w, and the subscript of the j-th dimension ranges from l_j to h_j.
4. ! The other conditions are the same as in 3, but column-major order is used.

#### Solution

Let n_i be the number of elements in the i-th dimension of the array, the calculation formula is: n_i = h_i - l_i + 1

    3. A[i_1]...[i_k] = base + 
                       (
                           (i_1 - l_1) * n_2 * ... * n_k +
                           ... + 
                           (i_k-1 - l_k-1) * n_k +
                           (i_k - l_k)
                       ) * w
                     
    4. A[i_1]...[i_k] = base + 
                       (
                           (i_1 - l_1) +
                           (i_2 - l_2) * n_1 + 
                           ... +
                           (i_k - l_k) * n_k-1 * n_k-2 * ... * n_1
                       ) * w

### 6.4.6

The subscript `i` of a row-major integer array `A[i, j]` ranges from 1 to 10, and the subscript `j` ranges from 1 to 20. Each integer occupies 4 bytes. Assuming the array A starts at byte 0, give the positions of the following elements:

1. A[4, 5]
2. A[10, 8]
3. A[3, 17]

#### Solution

Calculation formula: `((i-1) * 20 + (j-1)) * 4`
    
1. (3 * 20 + 4) * 4 = 256
2. (9 * 20 + 7) * 4 = 748
3. (2 * 20 + 16) * 4 = 224

### 6.4.7

Assume A is stored in column-major order and repeat Exercise 6.4.6.

#### Solution

Calculation formula: `((j-1) * 10 + (i-1)) * 4`

1. (4 * 10 + 3) * 4 = 172
2. (7 * 10 + 9) * 4 = 316
3. (16 * 10 + 2) * 4 = 648

### 6.4.8

The subscript `i` of a row-major real array `A[i, j, k]` ranges from 1 to 4, the subscript `j` ranges from 0 to 4, and the subscript `k` ranges from 5 to 10. Each real number occupies 8 bytes. Assuming the array A starts at byte 0, calculate the positions of the following elements:

1. A[3, 4, 5]
2. A[1, 2, 7]
3. A[4, 3, 9]

#### Solution

Calculation formula: `((i-1) * 5 * 6 + j * 6 + (k-5)) * 8`

1. ((3-1) * 5 * 6 + 4 * 6 + (5-5)) * 8 = 672
2. ((1-1) * 5 * 6 + 2 * 6 + (7-5)) * 8 = 112
3. ((4-1) * 5 * 6 + 3 * 6 + (9-5)) * 8 = 896

### 6.4.9

Assume A is stored in column-major order and repeat Exercise 6.4.8.

#### Solution

Calculation formula: `((k-5) * 4 * 5 + j * 4 + (i-1)) * 8`

1. ((5-5) * 20 + 4 * 4 + (3-1)) * 8 = 144
2. ((7-5) * 20 + 2 * 4 + (1-1)) * 8 = 384
3. ((9-5) * 20 + 3 * 4 + (4-1)) * 8 = 760