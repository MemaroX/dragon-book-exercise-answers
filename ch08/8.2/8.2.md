# Exercises for Section 8.2

### 8.2.1

Generate code for the following three-address statements assuming all variables are stored in memory locations.

1. x = 1
2. x = a
3. x = a + 1
4. x = a + b
5. The two statements
    - x = b * c
    - y = a + x

#### Answer

    1.  LD R1, #1
        ST x, R1

    2.  LD R1, a
        ST x, R1

    3.  LD R1, a
        ADD R1, R1, #1
        ST x, R1

    4.  LD R1, a
        LD R2, b
        ADD R1, R1, R2
        ST x, R1

    5.  LD R1, b
        LD R2, c
        MUL R1, R1, R2
        LD R3, a
        ADD R3, R3, R1
        ST y, R3

Note: For question 5, you can insert `ST x, R1` and `LD R1, x` after the third line of the generated assembly code. These two lines are redundant code (redundant store-load). It is easy to generate such redundant code using a simple code generation strategy; it is slower but still correct. There are optimisations specifically for this problem (redundant store-load elimination), so whether to generate it in the answer to this question seems acceptable.

### 8.2.2

Generate code for the following three-address statements assuming a and b are arrays whose elements are 4-byte values.

1. The four-statement sequence

        x = a[i]
        y = b[j]
        a[i] = y
        b[j] = x

2. The three-statement sequence

        x = a[i]
        y = b[i]
        z = x * y

3. The three-statement sequence

        x = a[i]
        y = b[x]
        a[i] = y

#### Answer

    1.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R3, j
        MUL R3, R3, #4
        LD R4, b(R3)
        ST a(R1), R4
        ST b(R3), R2

    2.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R1, b(R1)
        MUL R1, R2, R1
        ST z, R1

    3.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        MUL R2, R2, #4
        LD R2, b(R2)
        ST a(R1), R2

### 8.2.3

Generate code for the following three-address sequence assuming that p and q are in memory locations:

    y = *q
    q = q + 4
    *p = y
    p = p + 4

#### Answer

    LD R1, q
    LD R2, 0(R1)
    ADD R1, R1, #4
    ST q, R1
    LD R1, p
    ST 0(R1), R2
    ADD R1, R1, #4
    ST p, R1

### 8.2.4

Generate code for the following sequence assuming that x, y, and z are in memory locations:

        if x < y goto L1
        z = 0
        goto L2
    L1: z = 1

#### Answer

        LD R1, x
        LD R2, y
        SUB R1, R1, R2
        BLTZ R1, L1
        LD R1, #0
        ST z, R1
        BR L2
    L1: LD R1, #1
        ST z, R1

Note: When actually generating code, labels will correspond to specific numerical addresses, but this section has not yet reached that step, so it is fine to just use the original label names from the problem.

### 8.2.5

Generate code for the following sequence assuming that n is in a memory location:

        s = 0
        i = 0
    L1: if i > n goto L2
        s = s + i
        i = i + 1
        goto L1
    L2:

#### Answer

    Long version:

        LD R1, #0
        ST s, R1
        ST i, R1
    L1: LD R1, i
        LD R2, n
        SUB R2, R1, R2
        BGTZ R2, L2
        LD R2, s
        ADD R2, R2, R1
        ST s, R2
        ADD R1, R1, #1
        ST i, R1
        BR L1
    L2:

    Short version:

        LD R2, #0
        LD R1, R2
        LD R3, n
    L1: SUB R4, R1, R3
        BGTZ R4, L2
        ADD R2, R2, R1
        ADD R1, R1, #1
        BR L1
    L2:

Note: Short version optimisations: 1) eliminate redundant store-load 2) loop-invariant code motion 3) plus register allocation.

### 8.2.6

Determine the costs of the following instruction sequences:

    1.  LD R0, y
        LD R1, z
        ADD R0, R0, R1
        ST x, R0

    2.  LD R0, i
        MUL R0, R0, 8
        LD R1, a(R0)
        ST b, R1

    3.  LD R0, c
        LD R1, i
        MUL R1, R1, 8
        ST a(R1),R0

    4.  LD R0, p
        LD R1, 0(R0)
        ST x, R1

    5.  LD R0, p
        LD R1, x
        ST 0(R0), R1

    6.  LD R0, x
        LD R1, y
        SUB R0, R0, R1
        BLTZ *R3, R0

#### Answer

1. 2 + 2 + 1 + 2 = 7
2. 2 + 2 + 2 + 2 = 8
3. 2 + 2 + 2 + 2 = 8
4. 2 + 2 + 2 = 6
5. 2 + 2 + 2 = 6
6. 2 + 2 + 1 + 1 = 6

Note: The instruction set used in this book does not explicitly define the details of all instructions, but it seems that using variable names to specify memory addresses implicitly assumes that these variables are statically allocated. That is, in the truly generated instructions, these variable names will be replaced by their corresponding numerical address constants, and the address exists in an extra word after the instruction, which counts as an additional unit of overhead.

---

### Note

1. It is obvious that the content of this section is written very casually. It is recommended that numerical constants should all have a '#' prefix, except when used in addresses. For example, `LD R1, #1` and `ADD R1, R1, #1`.

2. In this book, Ri refers to register number i.

    1. In the process of translating to assembly code, can the value of i be arbitrarily specified (e.g., R3, R4, R1000) or are there some restrictions?

        Answer: For now, it's arbitrary. We will consider the case with restrictions later when the number of registers is limited.

    2. In addition, if R1 shown in the code is no longer needed in subsequent code, can a new value be loaded into R1? If so, how do we know that the previous R1 is no longer needed?

        Answer: It can be overwritten. As for how to know if the previous value is dead, it depends on the def-use chain. This is an important optimisation problem. For example, Section 9.2.5 discusses live variables, which is related to this.

3. Assembly code corresponding to `b = a[i]`:

    ```
    LD R1, i
    MUL R1, R1, 8
    LD R2, a(R1)
    ...
    ```

    Why does `a` not need to be loaded into a register first?

    Answer: This implicitly assumes that variables are statically allocated storage. The situation will change later when non-static variables are involved.